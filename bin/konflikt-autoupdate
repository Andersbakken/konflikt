#!/usr/bin/env bash
#
# konflikt-autoupdate - Wrapper script that monitors for upstream changes
# and automatically updates and restarts konflikt when new commits are available.
#
# Usage: konflikt-autoupdate [--interval SECONDS] [-- konflikt args...]
#
# Options:
#   --interval SECONDS   Check interval in seconds (default: 60)
#   --branch BRANCH      Branch to track (default: current branch)
#   --no-install         Skip npm install on update
#   --                   All arguments after -- are passed to konflikt
#
# Examples:
#   konflikt-autoupdate -- --role server --port 8080
#   konflikt-autoupdate --interval 300 -- --role client
#

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

# Default settings
CHECK_INTERVAL=60
TRACK_BRANCH=""
SKIP_INSTALL=false
KONFLIKT_ARGS=()

# State
APP_PID=""
RUNNING=true

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${BLUE}[autoupdate]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[autoupdate]${NC} $*"
}

log_warn() {
    echo -e "${YELLOW}[autoupdate]${NC} $*"
}

log_error() {
    echo -e "${RED}[autoupdate]${NC} $*"
}

usage() {
    head -n 20 "$0" | tail -n 17 | sed 's/^# \?//'
    exit 0
}

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --interval)
                CHECK_INTERVAL="$2"
                shift 2
                ;;
            --branch)
                TRACK_BRANCH="$2"
                shift 2
                ;;
            --no-install)
                SKIP_INSTALL=true
                shift
                ;;
            --help|-h)
                usage
                ;;
            --)
                shift
                KONFLIKT_ARGS=("$@")
                break
                ;;
            *)
                log_error "Unknown option: $1"
                usage
                ;;
        esac
    done
}

cleanup() {
    RUNNING=false
    log_info "Shutting down..."
    stop_app
    exit 0
}

stop_app() {
    if [[ -n "$APP_PID" ]] && kill -0 "$APP_PID" 2>/dev/null; then
        log_info "Stopping konflikt (PID: $APP_PID)..."
        kill -TERM "$APP_PID" 2>/dev/null || true

        # Wait for graceful shutdown (up to 10 seconds)
        local wait_count=0
        while kill -0 "$APP_PID" 2>/dev/null && [[ $wait_count -lt 10 ]]; do
            sleep 1
            ((wait_count++))
        done

        # Force kill if still running
        if kill -0 "$APP_PID" 2>/dev/null; then
            log_warn "Force killing konflikt..."
            kill -9 "$APP_PID" 2>/dev/null || true
        fi

        APP_PID=""
    fi
}

start_app() {
    log_info "Starting konflikt with args: ${KONFLIKT_ARGS[*]:-<none>}"

    cd "$PROJECT_DIR"
    node dist/app/index.js "${KONFLIKT_ARGS[@]}" &
    APP_PID=$!

    log_success "konflikt started (PID: $APP_PID)"
}

get_current_branch() {
    git -C "$PROJECT_DIR" rev-parse --abbrev-ref HEAD
}

get_local_commit() {
    local branch="${1:-HEAD}"
    git -C "$PROJECT_DIR" rev-parse "$branch"
}

get_remote_commit() {
    local branch="$1"
    git -C "$PROJECT_DIR" rev-parse "origin/$branch"
}

check_for_updates() {
    local branch="${TRACK_BRANCH:-$(get_current_branch)}"

    # Fetch latest from remote
    if ! git -C "$PROJECT_DIR" fetch origin "$branch" --quiet 2>/dev/null; then
        log_warn "Failed to fetch from origin"
        return 1
    fi

    local local_commit
    local remote_commit
    local_commit=$(get_local_commit "$branch")
    remote_commit=$(get_remote_commit "$branch")

    if [[ "$local_commit" != "$remote_commit" ]]; then
        log_info "Updates available!"
        log_info "  Local:  ${local_commit:0:8}"
        log_info "  Remote: ${remote_commit:0:8}"
        return 0
    fi

    return 1
}

perform_update() {
    local branch="${TRACK_BRANCH:-$(get_current_branch)}"

    cd "$PROJECT_DIR"

    log_info "Pulling latest changes..."
    if ! git pull origin "$branch"; then
        log_error "Failed to pull changes"
        return 1
    fi

    if [[ "$SKIP_INSTALL" != "true" ]]; then
        log_info "Running npm install..."
        if ! npm install; then
            log_error "Failed to install dependencies"
            return 1
        fi
    fi

    log_info "Building project..."
    if ! npm run build; then
        log_error "Failed to build project"
        return 1
    fi

    log_success "Update complete!"
    return 0
}

monitor_app() {
    # Check if the app is still running
    if [[ -n "$APP_PID" ]] && ! kill -0 "$APP_PID" 2>/dev/null; then
        log_warn "konflikt process died unexpectedly, restarting..."
        APP_PID=""
        start_app
    fi
}

main() {
    parse_args "$@"

    # Set up signal handlers
    trap cleanup SIGINT SIGTERM

    log_info "Starting konflikt-autoupdate"
    log_info "  Project dir: $PROJECT_DIR"
    log_info "  Check interval: ${CHECK_INTERVAL}s"
    log_info "  Track branch: ${TRACK_BRANCH:-<current>}"
    log_info "  Konflikt args: ${KONFLIKT_ARGS[*]:-<none>}"

    # Initial build check - ensure the project is built
    if [[ ! -f "$PROJECT_DIR/dist/app/index.js" ]]; then
        log_info "No build found, building project..."
        cd "$PROJECT_DIR"
        npm install
        npm run build
    fi

    # Start the app
    start_app

    # Main loop
    local last_check=0
    while $RUNNING; do
        local now
        now=$(date +%s)

        # Check for updates at the specified interval
        if (( now - last_check >= CHECK_INTERVAL )); then
            last_check=$now

            if check_for_updates; then
                log_info "Updating konflikt..."
                stop_app

                if perform_update; then
                    start_app
                else
                    log_error "Update failed, restarting with previous version..."
                    start_app
                fi
            fi
        fi

        # Monitor the app process
        monitor_app

        # Sleep briefly to avoid busy waiting
        sleep 1
    done
}

main "$@"
